---
title: "Aplicações de Modelos Lineares Generalizados"
author: "Elton Dantas de Oliveira Mesquita"
output:
  html_document:
    theme: readable
    highlight: breezedark
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{=html}
<style> body {text-align: justify} </style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Pacotes

```{r}
library(tidyverse)
library(psych)
library(plotly)
library(GGally)
library(hnp)
library(car)
library(nortest)
```

# Modelo Linear Normal

Para as aplicações a seguir, consideraremos o modelo de regressão normal linear

$$
y_i = \beta_1 + \beta_2x_{2i} + ... + \beta_px_{pi} + \epsilon_i, \quad i = 1,...,n
$$

em que os erros $e_i$ são variáveis aleatórias independentes, normalmente distribuídas, de média zero e variância $\sigma^2$ constante.

<br>

## Previsão de Vendas de Imóveis

### Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 23, página 112). Dados disponíveis em: <https://www.ime.usp.br/~giapaula/textoregressao.htm>

Neste exemplo, vamos modelar o preço de venda de imóveis a partir de dados relativos a uma amostra de 27 imóveis. As variáveis do conjunto de dados são:

-   ***imposto***: imposto do imóvel (em US\$ 100);

-   ***areaT***: área do terreno (em 1.000 pés quadrados);

-   ***areaC***: área construída (em 1.000 pés quadrados);

-   ***idade***: idade da residência (em anos);

-   ***preco***: preço de venda do imóvel (em US\$ 1.000).

Sendo assim, o nosso objetivo é encontrar o melhor ajuste linear que explique e quantifique a variável ***preço de venda***, a partir das demais.

```{r}
# Obtendo os dados
dados = read.table("dados/imoveis.dat")
colnames(dados) = c("imposto", "areaT", "areaC", "idade", "preco")
attach(dados)

# Algumas observações dos dados
head(dados)

# Medidas descritivas
describe(dados)
```

<br>

### Análise Descritiva

#### Box-plots

```{r}
plot_ly(type = "box") %>%
  add_trace(y = imposto, name = "imposto") %>% 
  add_trace(y = areaT, name = "área do terreno") %>% 
  add_trace(y = areaC, name = "área construída") %>%
  add_trace(y = idade, name = "idade do imóvel") %>%
  add_trace(y = preco, name = "preço de venda")
```

Em um resumo descritivo dos dados, observamos altas variâncias das variáveis idade e preço, destacando-se das demais. Com uma idade mediana de 40 anos, temos um imóvel de apenas 3 anos de idade. E com um preço mediano de US\$ 36.900, temos dois imóveis bem mais caros, custando US\$ 82.900 e US\$ 84.900.

Os gráficos de box-plot nos mostram que os dados possuem outliers e que as variáveis possuem distribuições assimétricas. Focando na nossa variável alvo, preço, os pontos destoantes são justamente os dois imóveis mais caros.

<br>

#### Densidades, Dispersões e Correlações

```{r}
g = ggpairs(dados, aes(color = I("slategray"), fill = I("slategray")),
            lower = list(continuous = wrap("smooth",col="black")),
            diag=list(continuous = wrap("densityDiag",alpha=0.5,size=1)))
ggplotly(g)
```

No gráfico acima, as curvas representadas na diagonal principal deixam mais evidente a constatação de assimetria nas distribuições observada nos box-plots. A variável preço possui correlações positivas fortes com as variáveis imposto, área do terreno e área construída, mas uma correlação negativa fraca com a variável idade. Em outras palavras, quanto maiores os valores de imposto, área construída e área do terreno, maior o preço de venda do imóvel.

Podemos observar também que há correlações relevantes entre as variáveis explicativas imposto, área construída e área do terreno. Isto nos dá indícios de multicolinearidade e, assim, uma possível redundância de informação. Então, talvez um modelo completo com todas as variáveis não seja o melhor.

<br>

### Modelo Completo

Nesse primeiro ajuste, consideraremos o modelo completo com todas as variáveis disponíveis.

$$
preço_i = \beta_0 + \beta_1imposto_i + \beta_2areaC_i + \beta_3areaT_i + \beta_4idade_i
$$

```{r}
model1 = lm(preco~.,dados)
summary(model1)
```

Verificamos que, para o modelo completo, as variáveis imposto e área construída são as únicas significativas e obtivemos um $R^2$ de 0.92, muito alto, indicando um possível bom ajuste aos dados amostrais. Porém, o $R^2$ por si só não nos garante que o modelo seja o mais adequado.

<br>

### Seleção de variáveis

Aplicaremos o critério de informação de Akaike (AIC) ao modelo completo, para selecionar as variáveis que deverão permanecer.

```{r}
MASS::stepAIC(model1)
```

O AIC nos retornou as variáveis imposto e área construída como aquelas que deverão ser mantidas no modelo, o qual chamaremos de modelo parcimonioso.

<br>

### Modelo Parcimonioso

```{r}
model2 = lm(preco~imposto+areaC,dados)
summary(model2)
```

E, assim, obtemos um modelo em que as variáveis imposto e área construída são altamente significativas.

Porém, na análise descritiva, observamos que as variáveis área construída e área do terreno possuem uma correlação considerável. Então, podemos ainda testar um segundo modelo parcimonioso com as variáveis imposto e área do terreno.

```{r}
model3 = lm(preco~imposto+areaT,dados)
summary(model3)
```

E, assim, obtemos um modelo em que a variável área do terreno passa de não significativa para pouco significativa, enquanto que a variável imposto continua bastante significativa.

<br>

### Diagnóstico

Agora, faremos a análise de diagnóstico dos dois modelos parcimoniosos propostos, para verificar suas adequações.

#### Envelope

```{r}
par(mfrow=c(1,2))
qqPlot(model2, pch = 16, main = "preco ~ imposto + areaC")
qqPlot(model3, pch = 16, main = "preco ~ imposto + areaT")
```

#### Teste de Normalidade

$H_0$: Os resíduos têm distribuição normal.

```{r}
# Shapiro-Wilk
shapiro.test(model2$residuals)
shapiro.test(model3$residuals)
```

Ao nível de 5% de significância, não rejeitamos a hipótese de que os resíduos tenham distribuição normal. Nos gráficos de envelope para o ajuste normal, os pontos estão dentro das bandas, porém a presença de ondulações é indício de variância não constante. Vamos verificar se de fato isso ocorre no gráfico de resíduos por valores ajustados.

#### Resíduos x Valores ajustados

```{r}
par(mfrow=c(1,2),mar=c(5,4,5,2))
residualPlot(model2, pch = 16, type = "rstudent",
             main = "preco ~ imposto + areaC",linear=F)
residualPlot(model3, pch = 16, type = "rstudent",
             main = "preco ~ imposto + areaC")
title("Resíduos studentizados x Valores ajustados",outer = TRUE)
```

Embora não haja violação do pressuposto de normalidade dos resíduos, o gráfico de resíduos por valores ajustados nos dá indícios de heterocedasticidade, isto é, variância não constante, como supomos no gráfico de envelope. Porém, esse comportamento pode estar sendo influenciado pelos dois pontos mais distantes que vemos acima.

<br>

#### Pontos Influentes

Partiremos agora para a investigação de possíveis pontos influentes, que podem estar atrapalhando a qualidade do ajuste.

Medidas de influência:

-   DFBetas (***dfb***): estatísticas que indicam o efeito da remoção de cada observação sobre as estimativas dos parâmetros do modelo;

-   DFFit (***dffit***) e Cook's D (***cook.d***): são estatísticas que indicam o efeito da remoção de cada observação sobre os valores ajustados do modelo;

-   COVRATIO (***cov.r***): estatística que indica o efeito da remoção de cada observação sobre a matriz de covariâncias do modelo, em outras palavras, mede a alteração na precisão das estimativas dos parâmetros do modelo;

-   HAT (***hat***): diagonal da matriz de projeção ($H = X(X'X)^{-1}X'$) da solução dos mínimos quadrados, é a métrica de alavancagem.

```{r}
inf = influence.measures(modelp)
summary(inf)
```

Baseando-se nas medidas de influência acima, que verificam o efeito da remoção de cada uma das observações individualmente, temos que os possíveis pontos de influência são as observações 9, 10 e 27. Percebemos também que a observação 27 é a mais crítica, por impactar nas estimativas dos parâmetros, nos valores ajustados e na variância do modelo. Também podemos constatar isso graficamente.

```{r}
# DISTANCIA DE COOK
plot(modelp, which=4, lwd=5, main="Distância de Cook x Observação", caption=F)
```

```{r}
cut = 2*3/27 # 2*p/n
plot(hatvalues(modelp), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem")
abline(h = cut, col = "red", lty = 2)
text(hatvalues(modelp) * as.integer(hatvalues(modelp) > cut),
     cex=0.8, p=1, offset=0.3)


plot(modelp,which=1:6)


```

As observações 9, 10 e 27 são referentes aos dados:

```{r}
dados[c(9,10,27),c("imposto","areaC","preco")]
```

#### Impacto das remoções das observações

Observação 9

```{r}
mlog.sem9 = lm(log(preco)~imposto+areaC,dados, subset = -9)
(mlog$coefficients - mlog.sem9$coefficients)/mlog$coefficients * 100

summary(mlog)
summary(mlog.sem9)
```

```{r}
mlog.sem10 = lm(log(preco)~imposto+areaC,dados,subset=-10)
(mlog$coefficients - mlog.sem10$coefficients)/mlog$coefficients * 100

summary(mlog)
summary(mlog.sem10)
```

```{r}
mlog.sem27 = lm(log(preco)~imposto+areaC,dados,subset=-27)
(mlog$coefficients - mlog.sem27$coefficients)/mlog$coefficients * 100

summary(mlog)
summary(mlog.sem27)
```

```{r}
model = lm(preco~imposto+areaT)
summary(model)
qqPlot(model)
residualPlot(model)
```

```{r}
plot(cooks.distance(modelp), pch = 16, lwd = 3,
     main = "Distância de Cook x Observação")

cut = 2*3/27
plot(hatvalues(modelp), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem")
abline(h = cut, col = "red", lty = 2)
```

```{r}
modelp.sem27 = lm(log(preco)~imposto+areaC,dados, subset = -27)
(modelp$coefficients - modelp.sem27$coefficients)/modelp$coefficients * 100

summary(modelp)
summary(modelp.sem27)
```

```{r}
gamma = glm(preco~areaC+imposto,dados, family = Gamma(link="identity"))
resumo = summary(gamma)
resumo
```

```{r}
shape = gamma.shape(gamma)

desvio_escal = resumo$deviance * shape$alpha

nivel_descrit = 1 - pchisq(desvio_escal,24)

nivel_descrit

fit.model = gamma
source("envel_gama")
source("diag_gama")

```

```{r}

```

```{r}
gamma.sem27 = glm(preco~areaC+imposto,dados, subset=-27,
                  family = Gamma(link="identity"))
(gamma$coefficients - gamma.sem27$coefficients)/gamma$coefficients * 100

summary(gamma)
summary(gamma.sem27)
```

```{r}
mlog.sem9 = lm(log(preco)~imposto+areaC,dados, subset = -9)
(mlog$coefficients - mlog.sem9$coefficients)/mlog$coefficients * 100

summary(mlog)
summary(mlog.sem9)
```
