---
title: "Aplicações de Modelos Lineares Generalizados"
author: "Elton Dantas de Oliveira Mesquita"
output:
  html_document:
    theme: readable
    highlight: breezedark
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Pacotes

```{r}
library(tidyverse)
library(psych)
library(plotly)
library(GGally)
library(car)
library(gridExtra)
library(cowplot)
```

<br>

# I. Modelo Linear Normal

Para a aplicação a seguir, consideraremos o modelo de regressão normal linear

$$
y_i = \beta_1 + \beta_2x_{2i} + ... + \beta_px_{pi} + \epsilon_i, \quad i = 1,...,n
$$

em que os erros $e_i$ são variáveis aleatórias independentes, normalmente distribuídas, de média zero e variância $\sigma^2$ constante.

<br>

## 1. Preço de Venda de Imóveis

### Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 23, página 112). Dados disponíveis em: [\<https://www.ime.usp.br/\~giapaula/textoregressao.htm\>](https://www.ime.usp.br/~giapaula/textoregressao.htm){.uri}, arquivo ***imoveis.dat***.

Neste exemplo, vamos modelar o preço de venda de imóveis a partir de dados relativos a uma amostra de 27 imóveis. As variáveis do conjunto de dados são:

-   ***imposto***: imposto do imóvel (em US\$ 100);

-   ***areaT***: área do terreno (em 1.000 pés quadrados);

-   ***areaC***: área construída (em 1.000 pés quadrados);

-   ***idade***: idade da residência (em anos);

-   ***preco***: preço de venda do imóvel (em US\$ 1.000).

Sendo assim, o nosso objetivo é encontrar o melhor ajuste linear que explique e quantifique a variável ***preço de venda*** a partir das demais.

```{r}
# Obtendo os dados
dados = read.table("dados/imoveis.dat")
colnames(dados) = c("imposto", "areaT", "areaC", "idade", "preco")
attach(dados)

# Algumas observações dos dados
head(dados)

# Medidas descritivas
describe(dados)
```

<br>

### Análise Descritiva

#### Box-plots

```{r}
plot_ly(type = "box") %>%
  add_trace(y = imposto, name = "imposto") %>% 
  add_trace(y = areaT, name = "área do terreno") %>% 
  add_trace(y = areaC, name = "área construída") %>%
  add_trace(y = idade, name = "idade do imóvel") %>%
  add_trace(y = preco, name = "preço de venda")
```

Em um breve resumo descritivo dos dados, observamos que as altas variâncias das variáveis idade e preço destacam-se das demais. Com uma idade mediana de 40 anos, temos um imóvel de apenas 3 anos de idade e, com um preço mediano de US\$ 36.900, temos dois imóveis bem mais caros nos valores de US\$ 82.900 e US\$ 84.900.

Os gráficos de box-plot nos mostram que os dados possuem outliers e que as variáveis possuem distribuições assimétricas. Focando na variável alvo, preço de venda, os pontos destoantes são justamente os dois imóveis mais caros.

<br>

#### Densidades, Dispersões e Correlações

```{r}
g = ggpairs(dados, aes(color = I("slategray"), fill = I("slategray")),
            lower = list(continuous = wrap("smooth",col="black")),
            diag=list(continuous = wrap("densityDiag",alpha=0.5,size=1)))
ggplotly(g)
```

No gráfico acima, as curvas representadas na diagonal principal deixam mais evidente a constatação de assimetria nas distribuições observada nos box-plots. A variável preço possui correlações positivas fortes com as variáveis imposto, área do terreno e área construída, mas uma correlação negativa fraca com a variável idade. Em outras palavras, quanto maiores os valores de imposto, área construída e área do terreno, maior o preço de venda do imóvel.

Podemos observar também que há correlações relevantes entre as variáveis explicativas imposto, área construída e área do terreno. Isso nos dá indícios de multicolinearidade e, assim, uma possível redundância de informação passada por essas variáveis. Então, talvez um modelo completo com todas as variáveis não seja o mais adequado.

<br>

### Modelo Completo

Nesse primeiro ajuste, consideraremos o modelo completo com todas as variáveis disponíveis.

$$
preço_i = \beta_0 + \beta_1imposto_i + \beta_2areaC_i + \beta_3areaT_i + \beta_4idade_i
$$

```{r}
model1 = lm(preco~.,dados)
summary(model1)
```

Verificamos que, para o modelo completo, as variáveis imposto e área construída são as únicas significativas e obtivemos um $R^2$ ajustado de 0.92, muito alto, indicando um possível bom ajuste aos dados amostrais. Porém, o $R^2$ por si só não nos garante que o modelo seja o mais adequado.

<br>

### Seleção de variáveis

Aplicaremos o critério de informação de Akaike (AIC) ao modelo completo, para selecionar as variáveis que deverão permanecer.

```{r}
MASS::stepAIC(model1)
```

O AIC nos retornou as variáveis imposto e área construída como aquelas que deverão ser mantidas no modelo, o qual chamaremos de modelo parcimonioso.

<br>

### Modelo Parcimonioso

```{r}
model2 = lm(preco~imposto+areaC,dados)
summary(model2)
```

E, assim, obtemos um modelo em que as variáveis imposto e área construída são altamente significativas.

Porém, na análise descritiva, observamos que as variáveis área construída e área do terreno possuem uma correlação considerável. Então, podemos ainda testar um segundo modelo parcimonioso considerando a variável área do terreno ao invés da área construída.

```{r}
model3 = lm(preco~imposto+areaT,dados)
summary(model3)
```

E, assim, obtemos um modelo em que a variável área do terreno passa de não significativa para pouco significativa ao nível de 10% de significância. Já a variável imposto continua bastante significativa ao nível de 1% de significância.

<br>

### Diagnóstico

Agora, faremos a análise de diagnóstico dos dois modelos parcimoniosos propostos, para verificar suas adequações.

#### Envelope

```{r}
par(mfrow=c(1,2))
qqPlot(model2, pch = 16, main = "preco ~ imposto + areaC")
qqPlot(model3, pch = 16, main = "preco ~ imposto + areaT")
```

<br>

#### Teste de Normalidade

$H_0$: Os resíduos têm distribuição normal.

```{r}
# Shapiro-Wilk
shapiro.test(model2$residuals)
shapiro.test(model3$residuals)
```

Ao nível de 5% de significância, não rejeitamos a hipótese de que os resíduos tenham distribuição normal. Nos gráficos de envelope para o ajuste normal, os pontos estão dentro das bandas, exceto pela observação 27 no modelo com área do terreno. Porém, a presença de leves ondulações pode ser indício de variância não constante. Vamos verificar se de fato isso ocorre no gráfico de resíduos por valores ajustados.

<br>

#### Resíduos x Valores ajustados

```{r}
residualPlot(model2, type = "rstudent", id = TRUE,
             ylab = "resíduo studentizado", xlab = "valor ajustado",
             main = "preco ~ imposto + areaC", pch = 16, quadratic = FALSE)
residualPlot(model3, type = "rstudent", id = TRUE,
             ylab = "resíduo studentizado", xlab = "valor ajustado",
             main = "preco ~ imposto + areaT", pch = 16, quadratic = FALSE)
```

Embora não haja violação do pressuposto de normalidade dos resíduos, o gráfico de resíduos por valores ajustados nos dá indícios de heterocedasticidade, isto é, variância não constante, como havíamos suposto a partir do gráfico de envelope. Porém, esse comportamento pode estar sendo influenciado pelas observações destoantes vistas na etapa descritiva. Além disso, podemos perceber no gráfico de resíduos por valores ajustados a presença de pontos aberrantes, isto é, muito além do intervalo [-2,2]. No caso do primeiro modelo parcimonioso, o ponto aberrante é a observação 10, enquanto que no segundo modelo parcimonioso são as observações 9 e 27. Sendo assim, a seguir, vamos verificar se de fato esses pontos estão influenciando na qualidade dos ajustes.

<br>

#### Pontos Influentes

Partiremos agora para a investigação de possíveis pontos influentes, que podem estar atrapalhando a qualidade do ajuste.

Medidas de influência:

-   DFBetas (***dfb***): estatísticas que indicam o efeito da remoção de cada observação sobre as estimativas dos parâmetros do modelo;

-   DFFit (***dffit***) e Cook's D (***cook.d***): são estatísticas que indicam o efeito da remoção de cada observação sobre os valores ajustados do modelo;

-   COVRATIO (***cov.r***): estatística que indica o efeito da remoção de cada observação sobre a matriz de covariâncias do modelo, em outras palavras, mede a alteração na precisão das estimativas dos parâmetros do modelo;

-   HAT (***hat***): diagonal da matriz de projeção ($H = X(X'X)^{-1}X'$) da solução dos mínimos quadrados, é a métrica de alavancagem.

```{r}
inf = influence.measures(model2)
summary(inf)

inf = influence.measures(model3)
summary(inf)
```

Baseando-se nas medidas de influência acima, que verificam o efeito da remoção de cada uma das observações individualmente, temos que os possíveis pontos de influência são as observações 9 e 27, para ambos os modelos parcimoniosos, e a observação 10, para o segundo. Percebemos também que a observação 27 é a mais crítica, por impactar nas estimativas dos dois parâmetros, nos valores ajustados e na variância do modelo. Também podemos constatar isso graficamente, como se segue a baixo.

```{r}
# DISTANCIA DE COOK

plot(model2, which=4, lwd=5, main="Distância de Cook x Observação", caption=F,
     sub.caption = "preco ~ imposto + areaC")
plot(model3, which=4, lwd=5, main="Distância de Cook x Observação", caption=F,
     sub.caption = "preco ~ imposto + areaT")
```

```{r}
# ALAVANCAGEM

cut = 2*3/27 # 2*p/n
plot(hatvalues(model2), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem",
     sub = "preco ~ imposto + areaC")
abline(h = cut, lty = 2, lwd = 2)
text(hatvalues(model2) * as.integer(hatvalues(model2) > cut),
     cex=0.8, p=1, offset=0.3)


cut = 2*3/27 # 2*p/n
plot(hatvalues(model3), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem",
     sub = "preco ~ imposto + areaT")
abline(h = cut, lty = 2, lwd = 2)
text(hatvalues(model3) * as.integer(hatvalues(model3) > cut),
     cex=0.8, p=1, offset=0.3)


```

As observações 9, 10 e 27 são referentes aos dados:

```{r}
dados[c(9,10,27),c("imposto","areaC","areaT","preco")]
```

Os imóveis 9 e 10 possuem os valores de imposto mais elevados e as maiores áreas de terreno e de construção. De acordo com a relação linear identificada na etapa descritiva e a significância dessas variáveis para o modelo preditivo, podemos dizer que essas características justificam um alto preço de venda. Porém, os valores atribuídos aos imóveis 9 e 10 são muito mais elevados que os esperados pelo modelo proposto a imóveis com os mesmos atributos. Já a observação 27 causa estranheza por ter um valor de imposto tão alto e próximo aos dos imóveis 9 e 10, mesmo tendo menos da metade de suas áreas de terreno e de construção e custando pouco menos da metade que o imóvel 10.

<br>

#### Impacto das remoções das observações

```{r}
# Compara os coeficientes e seus respectivos p-valores de um modelo
# após a remoção de uma observação
impacto = function(m1, m2){
  imp = (coef(m1) - coef(m2))/coef(m1) * 100
  impacto = data.frame(coef_com_i = coef(m1),
                       coef_sem_i = coef(m2),
                       impacto = imp,
                       pval_com_i = summary(m1)$coefficients[,4],
                       pval_sem_i = summary(m2)$coefficients[,4])
  return(impacto)
}
```

-   Observação i=9:

    ```{r}
    model2_sem9 = lm(preco~imposto+areaC,dados,subset=-9)
    impacto(model2,model2_sem9)

    model3_sem9 = lm(preco~imposto+areaT,dados,subset=-9)
    impacto(model3,model3_sem9)
    ```

    A remoção da observação 9 não teve impactos relevantes nos coeficientes dos dois modelos parcimoniosos e também não causou mudança inferencial, uma vez que as variáveis imposto, área construída e área do terreno permaneceram igualmente significativas nos respectivos modelos;

-   Observação i=10:

    ```{r}
    model2_sem10 = lm(preco~imposto+areaC,dados,subset=-10)
    impacto(model2,model2_sem10)

    model3_sem10 = lm(preco~imposto+areaT,dados,subset=-10)
    impacto(model3,model3_sem10)
    ```

    A remoção da observação 10 não causou impactos relevantes nos coeficientes do primeiro modelo parcimonioso e também não ocasionou mudança inferencial, tendo as variáveis imposto e área construída mantido seus níveis de significância. Já no segundo modelo parcimonioso, a remoção da observação 10 ocasionou uma mudança inferencial, uma vez que a variável área de terreno perde sua significância;

-   Observação i=27:

    ```{r}
    model2_sem27 = lm(preco~imposto+areaC,dados,subset=-27)
    impacto(model2,model2_sem27)

    model3_sem27 = lm(preco~imposto+areaT,dados,subset=-27)
    impacto(model3,model3_sem27)
    ```

    A remoção da observação 27 impactou em mudança inferencial nos dois modelos parcimoniosos. Enquanto que no primeiro, a significância da variável área construída é reduzida, no segundo, a variável área do terreno perde completamente sua significância.

<br>

Como o segundo modelo parcimonioso não nos trouxe nenhuma melhoria para o ajuste e as conclusões sobre os pontos de influência não favoreceram a permanência da variável área do terreno, optaremos pelo primeiro modelo parcimonioso com as variáveis imposto e área construída sugerido inicialmente pelo critério de seleção de Akaike.

A partir dos gráficos de resíduos por valores ajustados, de distância de Cook e de alavancagem, podemos fazer as seguintes classificações:

-   Ponto aberrante: observação 10;

-   Pontos de alavanca: observações 9, 10 e 27;

-   Ponto influente: observação 27.

<br>

## Interpretação

Então, concluímos que

$$
preço_i = 0.79 + 2.30*imposto_i + 13.93*areaC_i \quad ,
$$

onde:

-   A cada US\$ 100,00 acrescidos no valor de imposto, aumenta-se, em média, US\$ 2.300,00 no preço de venda;

-   A cada 1.000 metros quadrados de área construída acrescidos, aumenta-se, em média, US\$ 13.930,00 no preço de venda.

<br>

# II. Modelo Gama

## 1. Tempo de Vida de Pacientes com Leucemia

### Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 23, página 182). Dados disponíveis em: [\<https://www.ime.usp.br/\~giapaula/textoregressao.htm\>](https://www.ime.usp.br/~giapaula/textoregressao.htm){.uri}, arquivo ***sobrev.dat***.

O conjunto de dados a seguir refere-se à classificação de pacientes com leucemia segundo a ausência ou presença de uma característica morfológica nas células brancas. Os pacientes classificados de AG positivo foram aqueles identificados com a presença dessa característica e os pacientes classificados em AG negativo os que não apresentaram. O conjunto de dados também inclui o tempo de sobrevivência do paciente (em semanas) após o diagnóstico da doença e o número de células brancas (WBC) no momento do diagnóstico.

Variáveis:

-   ***WBC***: número de células brancas no momento do diagnóstico;

-   ***TEMPO***: tempo de sobrevivência do paciente (em semanas) após o diagnóstico da doença;

-   ***AG***: 0 em caso da ausência da característica e 1 em caso da presença.

Supondo que o tempo de sobrevivência após o diagnóstico segue uma distribuição gama, vamos propor um modelo para explicar o tempo médio de sobrevivência dados $log(WBC)$ e AG (= 1 se positivo, = 0 se negativo).

Denotaremos por $T_{ij}$ o tempo de sobrevivência do i-ésimo paciente com a j-ésima classificação, $i = 1,…,33$ e $j = 1,2$.

```{r}
# Obtendo os dados
dados = read.csv("dados/sobrev.csv")
dados$AG = factor(dados$AG)
attach(dados)
```

<br>

### Análise Descritiva

Médias estimadas para o tempo de sobrevivência, considerando o fator AG:

```{r}
# AG Negativo
dados_ag0 = dados %>% filter(AG==0)
mean(dados_ag0$TEMPO)

# AG Positivo
dados_ag1 = dados %>% filter(AG==1)
mean(dados_ag1$TEMPO)
```

A partir da diferença entre as médias amostrais acima, podemos supor que os pacientes com o fator AG positivo sobreviveram por mais tempo que aqueles com fator AG negativo.

<br>

Coeficientes de variação do tempo de sobrevivência, considerando o fator AG:

```{r}
# Tempo, AG = 0
sd(dados_ag0$TEMPO)/mean(dados_ag0$TEMPO) * 100

# Tempo, AG = 1
sd(dados_ag1$TEMPO)/mean(dados_ag1$TEMPO) * 100
```

<br>

#### Box-plots

Ignorando o fator AG, temos o seguinte boxplot:

```{r}
plot_ly(type = "box", y = TEMPO, name = "TEMPO", color = I("slategray"))
```

Considerando o fator AG, temos os seguintes boxplots:

```{r}
plot_ly(type = "box",
        y = TEMPO, x = AG, name = AG,
        color = AG, colors = c("darkred","darkgreen")) %>% 
  layout(title = "TEMPO x AG")
```

Os gráficos de box-plot evidenciam a assimetria na distribuição da variável tempo de sobrevivência e também apontam a presença de um outlier entre os indivíduos com fator AG negativo. Esse outlier corresponde ao paciente que, mesmo com o fator AG negativo, conseguiu sobreviver a 65 semanas. Nos dados, esse paciente é a 19ª observação.

<br>

#### Densidades, Dispersões e Correlações

Ignorando o fator AG, temos a seguinte densidade aproximada do tempo de sobrevivência:

```{r}
ggplot(dados,aes(x=TEMPO)) +
  geom_density(fill = "slategray", color ="slategray",lwd = 1, alpha = 0.5) +
  ggtitle("Densidade: TEMPO") +
  theme_bw()
```

Considerando o fator AG, temos as seguintes dispersões, densidades e correlações:

```{r}
g = ggpairs(dados[c("WBC","TEMPO")],
            aes(color = AG),
            lower = list(continuous = wrap("smooth",col="black")),
            diag = list(continuous = wrap("densityDiag", alpha = 0.5, size = 1)))
ggplotly(g)
```

De maneira geral, percebemos uma correlação fraca de -0,33 entre as variáveis WBC e TEMPO. Considerando o fator AG, a correlação é praticamente nula no caso de AG negativo e moderada no caso de AG positivo. Em outras palavras, na presença da característica morfológica, o tempo de sobrevivência tende a diminuir conforme o número de celulas brancas aumentam.

<br>

### Ajuste

Supondo que $T_{ij}$ são variáveis aleatórias independentes tais que $T_{ij} \sim Gama(\mu_{ij},\phi)$ e que $g(\mu_{ij}) = \eta_{ij}$, com $\eta_{ij} = \bf{x}_{ij}^\top\beta$, $\bf{x}_{ij}^\top$ contendo os valores das variáveis explicativas $log(WBC)$ e $AG$, e $\beta$ o vetor de parâmetros.

Assumimos que $T_{ij}$ segue uma distribuição Gama de média $\mu_i$ e parâmetro de dispersão $\phi^{-1}$. Vamos, então, propor um modelo cuja parte sistemática é dada por

$$
\log(\mu_{ij}) = \alpha + \gamma_j + \beta\log(WBC_{ij}) \; ,
$$

em que $\gamma_{1} = 0$.

#### Modelo com Ligação Logarítmica

```{r}
model1 = glm(TEMPO ~ log(WBC) + AG, dados, family = Gamma(link = "log"))
resumo = summary(model1)
resumo
```

Para o modelo obtido, ao nível de 5% de significância, as variáveis log(WBC) e AG são significativas.

```{r}
shape = MASS::gamma.shape(model1)

desvio_escal = resumo$deviance * shape$alpha
nivel_descrit = 1 - pchisq(desvio_escal, model1$df.residual)
nivel_descrit
```

Também ao nível de 5% de significância, não rejeitamos a hipótese de que o modelo seja adequado.

<br>

#### Seleção de Variáveis

```{r}
MASS::stepAIC(model1)
```

Pelo critério de seleção de Akaike, devemos manter as duas variáveis no modelo.

<br>

### Diagnóstico

#### Envelope

```{r}
# ENVELOPE
fit.model = model1
source("envel_gama")
```

Pelo gráfico de envelope, verificamos que todos os pontos se encontram dentro das bandas.

```{r}
par(mfrow=c(2,2))
# RESÍDUOS STUDENTIZADOS
residualPlot(model1, type = "deviance", id = TRUE,
             ylab = "res. compon. do desvio", xlab = "valor ajustado",
             pch = 16, smooth = F)
abline(h = c(-2,2), col="red")

# VARIÁVEL Z
w = model1$weights
eta = model1$linear.predictors
z = eta + resid(fit.model, type="pearson")/sqrt(w)
plot(model1$linear.predictors, z,
     xlab = "Preditor Linear", ylab = "Variável z", pch = 16)

# ALAVANCAGEM
cut = min(sort(hatvalues(model1), decreasing = TRUE)[1:3])
plot(hatvalues(model1), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem")
text(hatvalues(model1) * as.integer(hatvalues(model1) >= cut),
     cex=0.8, p=1, offset=0.3)

# DISTÂNCIA DE COOK
plot(model1, which=4, lwd=3, main = "Distância de Cook", caption = F)
```

No gráfico de resíduos por valores ajustados, percebemos uma boa distribuição dos pontos no intervalo de -2 a 2. Embora seja perceptível também um afunilamento à direita, a quantidade de pontos nessa região não é suficiente para indicar que seja uma tendência. Não há presença de pontos aberrantes, uma vez que todos os pontos estão dentro ou muito próximo do intervalo de -2 a 2. A observação 33 fica em evidência no gráfico de distância de Cook, mas não a consideraremos para análise uma vez que a distância não é expressiva em escala. No gráfico de alavancagem, a observação 2 se destaca e, sendo assim, investigaremos sua possível influência na qualidade do ajuste.

<br>

#### Pontos Influentes

```{r}
summary(influence.measures(model1))
```

As medidas de influência acima apontam apenas para a observação 2 como possível ponto influente.

<br>

#### Impacto das remoções das observações

```{r}
model1_sem2 = glm(TEMPO ~ log(WBC) + AG, dados, subset = -2,
                   family = Gamma(link = "log"))
impacto(model1, model1_sem2)
```

Ao nível de 5% de significância, verificamos que a variável log(WBC) deixa de ser significativa quando removemos a observação 2. Sendo assim, ela causa mudança infefrencial e classifica-se como ponto de alavanca e influente.

<br>

### Interpretação

Com essa análise, chegamos ao seguinte modelo para explicar o tempo médio de sobrevivência:

$$
\begin{aligned}
\log(\mu_{i1}) &= 5.8 - 0.3\log(WBC_{i1}) \; ; \\
\log(\mu_{i2}) &= 6.8 - 0.3\log(WBC_{i2}) \; .
\end{aligned}
$$

Fixando-se o fator $\gamma_{j}$, temos que

$$
\frac{\mu_{j}(x+1)}{\mu_{j}(x)} = \frac{\exp{(5.8+ \gamma_j -0.3(x+1))}}{\exp{(5.8 + \gamma_j - 0.3x)}}
=\exp{(-0.3)
= 0.74} \; .
$$

Alterando-se o fator $\gamma_j$, temos que

$$
\frac{\mu_{i2}}{\mu_{i1}} = \frac{\exp{(5.8 + \gamma_2 - 0.3X_{i2})}}{\exp{(5.8 + \gamma_1 - 0.3X_{i1})}}
= \exp{(\gamma_2)}
= 2.72
$$

De onde concluímos que, ao fixarmos o fator característica morfológica, o acréscimo de 1 unidade à variável $\log(WBC)$ representa, em média, uma redução de 26% do tempo de sobrevivência. Já considerando a característica morfológica, o fato do paciente apresentá-la representa um aumento médio de 172% no tempo de sobrevivência.

<br>

# III. Modelo para Dados Binários

## 1. Dose-Resposta

### Dados

Os conjuntos de dados apresentados a seguir são provenientes de um experimento dose-resposta, conduzido para avaliar a influência dos extratos vegetais "aquoso frio de folhas", "aquoso frio de frutos" e um extrato químico, respectivamente, na morte de um determinado tipo de caramujo. Para cada conjunto, ajustaremos um modelo logístico linear simples e um modelo log-log linear simples. Para o melhor ajuste, usando envelope como critério, encontraremos um intervalo assintótico de 95% para a dose letal $DL_{50}$.

Dados do *Extrato Aquoso Frio de Folhas:*

```{r}
dose1 = read.table("dados/dose1.dat", col.names = c("dose","expostos","mortos"))
dose1 = dose1 %>% mutate(restantes = expostos - mortos,
                         prop.mort = mortos/expostos,
                         prop.rest = restantes/expostos)
dose1
```

Dados do *Extrato Aquoso Frio de Frutos:*

```{r}
dose2 = read.table("dados/dose2.dat", col.names = c("dose","expostos","mortos"))
dose2 = dose2 %>% mutate(restantes = expostos - mortos,
                         prop.mort = mortos/expostos,
                         prop.rest = restantes/expostos)
dose2
```

Dados do *Extrato Químico:*

```{r}
dose3 = read.table("dados/dose3.dat", col.names = c("dose","expostos","mortos"))
dose3 = dose3 %>% mutate(restantes = expostos - mortos,
                         prop.mort = mortos/expostos,
                         prop.rest = restantes/expostos)
dose3
```

### 1.1 Proporção de Caramujos Mortos por Dose

```{r}
p1 = ggplot(dose1, aes(x = dose, y = prop.mort)) +
  geom_col(fill = "darkred") +
  ylab("proporção") +
  labs(title = "Extrato Aquoso Frio de Folhas") +
  theme_bw()

p2 = ggplot(dose2, aes(x = dose, y = prop.mort)) +
  geom_col(fill = "darkred") +
  ylab("proporção") +
  labs(title = "Extrato Aquoso Frio de Frutos") +
  theme_bw()

p3 = ggplot(dose3, aes(x = dose, y = prop.mort)) +
  geom_col(fill = "darkred") +
  ylab("proporção") +
  labs(title = "Extrato Químico") +
  theme_bw()

plot_grid(p1,p2,p3,ncol=2)
```

### 1.2 Modelos Logístico Linear Simples

```{r}
# EAF Folhas
log1 = glm(as.matrix(dose1[3:4]) ~ dose, data = dose1, family=binomial)
summary(log1)

# EAF Frutos
log2 = glm(as.matrix(dose2[3:4]) ~ dose, data = dose2, family=binomial)
summary(log2)

# E Químico
log3 = glm(as.matrix(dose3[3:4]) ~ dose, data = dose3, family=binomial)
summary(log3)
```

#### Testes de Ajuste

```{r}
# EAF Folhas
1 - pchisq(log1$deviance, log1$df.residual)

# EAF Frutos
1 - pchisq(log2$deviance, log1$df.residual)

# E Químico
1 - pchisq(log3$deviance, log1$df.residual)
```

<br>

### 1.3 Modelos Complementar Log-log

```{r}
# EAF Folhas
cloglog1 = glm(as.matrix(dose1[3:4]) ~ dose, data = dose1,
               family = binomial(link = "cloglog"))
summary(cloglog1)

# EAF Frutos
cloglog2 = glm(as.matrix(dose2[3:4]) ~ dose, data = dose2,
               family = binomial(link = "cloglog"))
summary(cloglog2)

# E Químico
cloglog3 = glm(as.matrix(dose3[3:4]) ~ dose, data = dose3,
               family = binomial(link = "cloglog"))
summary(cloglog3)
```

<br>

#### Teste de Ajuste

```{r}
# EAF Folhas
1 - pchisq(cloglog1$deviance, cloglog1$df.residual)

# EAF Frutos
1 - pchisq(cloglog2$deviance, cloglog2$df.residual)

# E químico
1 - pchisq(cloglog3$deviance, cloglog3$df.residual)
```

### 1.4 Envelopes

***Extrato Aquoso Frio de Folhas:***

```{r}
fit.model = log1
ntot = dose1$expostos
source("envelr_bino.txt")

fit.model = cloglog1
ntot = dose1$expostos
source("envelr_bino_cloglog.txt")
```

***Extrato Aquoso Frio de Frutos:***

```{r}
fit.model = log2
ntot = dose2$expostos
source("envelr_bino.txt")

fit.model = cloglog2
ntot = dose2$expostos
source("envelr_bino_cloglog.txt")
```

***Extrato Químico:***

```{r}
fit.model = log3
ntot = dose3$expostos
source("envelr_bino.txt")

fit.model = cloglog3
ntot = dose3$expostos
source("envelr_bino_cloglog.txt")
```

### 1.5 Curvas Logísticas Ajustadas

```{r}
pi_log1 = exp(log1$coeff[1] + log1$coeff[2] * dose1$dose) /
  (1 + exp(log1$coeff[1] + log1$coeff[2] * dose1$dose))

p_log1 = ggplot(dose1, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_log1) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Folhas - Log simples") +
  theme_bw()

pi_cloglog1 = exp(cloglog1$coeff[1] + cloglog1$coeff[2]*dose1$dose) /
  (1 + exp(cloglog1$coeff[1] + cloglog1$coeff[2]*dose1$dose))

p_cloglog1 = ggplot(dose1, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_cloglog1) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Folhas - Complem. Log-log") +
  theme_bw()



pi_log2 = exp(log2$coeff[1] + log2$coeff[2] * dose2$dose) /
  (1 + exp(log2$coeff[1] + log2$coeff[2] * dose2$dose))

p_log2 = ggplot(dose2, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_log2) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Frutos - Log simples") +
  theme_bw()

pi_cloglog2 = exp(cloglog2$coeff[1] + cloglog2$coeff[2]*dose2$dose) /
  (1 + exp(cloglog2$coeff[1] + cloglog2$coeff[2]*dose2$dose))

p_cloglog2 = ggplot(dose2, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_cloglog2) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Frutos - Complem. Log-log") +
  theme_bw()



pi_log3 = exp(log3$coeff[1] + log3$coeff[2] * dose3$dose) /
  (1 + exp(log3$coeff[1] + log3$coeff[2] * dose3$dose))

p_log3 = ggplot(dose3, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_log3) +
  ylab("prop. mortos") +
  ggtitle("E. Químico - Log simples") +
  theme_bw()

pi_cloglog3 = exp(cloglog3$coeff[1] + cloglog3$coeff[2]*dose3$dose) /
  (1 + exp(cloglog3$coeff[1] + cloglog3$coeff[2]*dose3$dose))

p_cloglog3 = ggplot(dose3, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_cloglog3) +
  ylab("prop. mortos") +
  ggtitle("E. Químico - Complem. Log-log") +
  theme_bw()


plot_grid(p_log1,p_cloglog1,
          p_log2,p_cloglog2,
          p_log3,p_cloglog3, ncol = 2)
```

### 1.6 Dose Letal ($DL_{50}$) para os Modelos Log Linear Simples

```{r}
# DOSE LETAL ESTIMATIVA PONTUAL
DL_100p = function(model,p){
  (1/model$coeff[2])*(log(p/(1-p)) - model$coeff[1])
}


# DOSE LETAL ESTIMATIVA INTERVALAR, 95% DE CONFIANÇA
DL_IC_log = function(model, p, gama){
  db = cbind(-1/model$coeff[2],
             1/(model$coeff[2]^2)*(model$coeff[1]-log(p/(1-p))))
  
  X = model.matrix(log_dose1)
  w = log_dose1$weights
  W = diag(w)
  
  Var = db %*% solve(t(X) %*% W %*% X) %*% t(db)
  
  LI = DL_100p(model, 0.5) - qnorm((1+gama)/2)*sqrt(Var)
  LS = DL_100p(model, 0.5) + qnorm((1+gama)/2)*sqrt(Var)
  
  return(c(LI,LS))
}
```

```{r}
data.frame(extrato = c("EAF de Folhas","EAF de Frutos", "E Químico"),
           LI = c(DL_IC_log(log1, 0.5, 0.95)[1],
                  DL_IC_log(log2, 0.5, 0.95)[1],
                  DL_IC_log(log3, 0.5, 0.95)[1]),
           DL_100p = c(DL_100p(log1,0.5),DL_100p(log2,0.5),DL_100p(log3,0.5)),
           LS = c(DL_IC_log(log1, 0.5, 0.95)[2],
                  DL_IC_log(log2, 0.5, 0.95)[2],
                  DL_IC_log(log3, 0.5, 0.95)[2]))
```
