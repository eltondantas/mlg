---
title: "Aplicações de Modelos Lineares Generalizados"
author: "Elton Dantas de Oliveira Mesquita"
output:
  html_document:
    theme: readable
    highlight: breezedark
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Pacotes

```{r}
library(tidyverse)
library(psych)
library(plotly)
library(GGally)
library(car)
library(gridExtra)
library(cowplot)
library(DescTools)
```

<br>

# I. Modelo Linear Normal

Para a aplicação a seguir, consideraremos o modelo de regressão normal linear

$$
y_i = \beta_1 + \beta_2x_{2i} + ... + \beta_px_{pi} + \epsilon_i, \quad i = 1,...,n
$$

em que os erros $e_i$ são variáveis aleatórias independentes, normalmente distribuídas, de média zero e variância $\sigma^2$ constante.

<br>

## 1. Preço de Venda de Imóveis

### Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 23, página 112). Dados disponíveis em: [\<https://www.ime.usp.br/\~giapaula/textoregressao.htm\>](https://www.ime.usp.br/~giapaula/textoregressao.htm){.uri}, arquivo ***imoveis.dat***.

Neste exemplo, vamos modelar o preço de venda de imóveis a partir de dados relativos a uma amostra de 27 imóveis. As variáveis do conjunto de dados são:

-   ***imposto***: imposto do imóvel (em US\$ 100);

-   ***areaT***: área do terreno (em 1.000 pés quadrados);

-   ***areaC***: área construída (em 1.000 pés quadrados);

-   ***idade***: idade da residência (em anos);

-   ***preco***: preço de venda do imóvel (em US\$ 1.000).

Sendo assim, o nosso objetivo é encontrar o melhor ajuste linear que explique e quantifique a variável ***preço de venda*** a partir das demais.

```{r}
# Obtendo os dados
dados = read.table("dados/imoveis.dat")
colnames(dados) = c("imposto", "areaT", "areaC", "idade", "preco")
attach(dados)

# Algumas observações dos dados
head(dados)

# Medidas descritivas
describe(dados)
```

<br>

### Análise Descritiva

#### Box-plots

```{r}
plot_ly(type = "box") %>%
  add_trace(y = imposto, name = "imposto") %>% 
  add_trace(y = areaT, name = "área do terreno") %>% 
  add_trace(y = areaC, name = "área construída") %>%
  add_trace(y = idade, name = "idade do imóvel") %>%
  add_trace(y = preco, name = "preço de venda")
```

Em um breve resumo descritivo dos dados, observamos que as altas variâncias das variáveis idade e preço destacam-se das demais. Com uma idade mediana de 40 anos, temos um imóvel de apenas 3 anos de idade e, com um preço mediano de US\$ 36.900, temos dois imóveis bem mais caros nos valores de US\$ 82.900 e US\$ 84.900.

Os gráficos de box-plot nos mostram que os dados possuem outliers e que as variáveis possuem distribuições assimétricas. Focando na variável alvo, preço de venda, os pontos destoantes são justamente os dois imóveis mais caros.

<br>

#### Densidades, Dispersões e Correlações

```{r}
g = ggpairs(dados, aes(color = I("slategray"), fill = I("slategray")),
            lower = list(continuous = wrap("smooth",col="black")),
            diag=list(continuous = wrap("densityDiag",alpha=0.5,size=1)))
ggplotly(g)
```

No gráfico acima, as curvas representadas na diagonal principal deixam mais evidente a constatação de assimetria nas distribuições observada nos box-plots. A variável preço possui correlações positivas fortes com as variáveis imposto, área do terreno e área construída, mas uma correlação negativa fraca com a variável idade. Em outras palavras, quanto maiores os valores de imposto, área construída e área do terreno, maior o preço de venda do imóvel.

Podemos observar também que há correlações relevantes entre as variáveis explicativas imposto, área construída e área do terreno. Isso nos dá indícios de multicolinearidade e, assim, uma possível redundância de informação passada por essas variáveis. Então, talvez um modelo completo com todas as variáveis não seja o mais adequado.

<br>

### Modelo Completo

Nesse primeiro ajuste, consideraremos o modelo completo com todas as variáveis disponíveis.

$$
preço_i = \beta_0 + \beta_1imposto_i + \beta_2areaC_i + \beta_3areaT_i + \beta_4idade_i
$$

```{r}
model1 = lm(preco~.,dados)
summary(model1)
```

Verificamos que, para o modelo completo, as variáveis imposto e área construída são as únicas significativas e obtivemos um $R^2$ ajustado de 0.92, muito alto, indicando um possível bom ajuste aos dados amostrais. Porém, o $R^2$ por si só não nos garante que o modelo seja o mais adequado.

<br>

### Seleção de variáveis

Aplicaremos o critério de informação de Akaike (AIC) ao modelo completo, para selecionar as variáveis que deverão permanecer.

```{r}
MASS::stepAIC(model1)
```

O AIC nos retornou as variáveis imposto e área construída como aquelas que deverão ser mantidas no modelo, o qual chamaremos de modelo parcimonioso.

<br>

### Modelo Parcimonioso

```{r}
model2 = lm(preco~imposto+areaC,dados)
summary(model2)
```

E, assim, obtemos um modelo em que as variáveis imposto e área construída são altamente significativas.

Porém, na análise descritiva, observamos que as variáveis área construída e área do terreno possuem uma correlação considerável. Então, podemos ainda testar um segundo modelo parcimonioso considerando a variável área do terreno ao invés da área construída.

```{r}
model3 = lm(preco~imposto+areaT,dados)
summary(model3)
```

E, assim, obtemos um modelo em que a variável área do terreno passa de não significativa para pouco significativa ao nível de 10% de significância. Já a variável imposto continua bastante significativa ao nível de 1% de significância.

<br>

### Diagnóstico

Agora, faremos a análise de diagnóstico dos dois modelos parcimoniosos propostos, para verificar suas adequações.

#### Envelope

```{r}
par(mfrow=c(1,2))
qqPlot(model2, pch = 16, main = "preco ~ imposto + areaC")
qqPlot(model3, pch = 16, main = "preco ~ imposto + areaT")
```

<br>

#### Teste de Normalidade

$H_0$: Os resíduos têm distribuição normal.

```{r}
# Shapiro-Wilk
shapiro.test(model2$residuals)
shapiro.test(model3$residuals)
```

Ao nível de 5% de significância, não rejeitamos a hipótese de que os resíduos tenham distribuição normal. Nos gráficos de envelope para o ajuste normal, os pontos estão dentro das bandas, exceto pela observação 27 no modelo com área do terreno. Porém, a presença de leves ondulações pode ser indício de variância não constante. Vamos verificar se de fato isso ocorre no gráfico de resíduos por valores ajustados.

<br>

#### Resíduos x Valores ajustados

```{r}
residualPlot(model2, type = "rstudent", id = TRUE,
             ylab = "resíduo studentizado", xlab = "valor ajustado",
             main = "preco ~ imposto + areaC", pch = 16, quadratic = FALSE)
residualPlot(model3, type = "rstudent", id = TRUE,
             ylab = "resíduo studentizado", xlab = "valor ajustado",
             main = "preco ~ imposto + areaT", pch = 16, quadratic = FALSE)
```

Embora não haja violação do pressuposto de normalidade dos resíduos, o gráfico de resíduos por valores ajustados nos dá indícios de heterocedasticidade, isto é, variância não constante, como havíamos suposto a partir do gráfico de envelope. Porém, esse comportamento pode estar sendo influenciado pelas observações destoantes vistas na etapa descritiva. Além disso, podemos perceber no gráfico de resíduos por valores ajustados a presença de pontos aberrantes, isto é, muito além do intervalo [-2,2]. No caso do primeiro modelo parcimonioso, o ponto aberrante é a observação 10, enquanto que no segundo modelo parcimonioso são as observações 9 e 27. Sendo assim, a seguir, vamos verificar se de fato esses pontos estão influenciando na qualidade dos ajustes.

<br>

#### Pontos Influentes

Partiremos agora para a investigação de possíveis pontos influentes, que podem estar atrapalhando a qualidade do ajuste.

Medidas de influência:

-   DFBetas (***dfb***): estatísticas que indicam o efeito da remoção de cada observação sobre as estimativas dos parâmetros do modelo;

-   DFFit (***dffit***) e Cook's D (***cook.d***): são estatísticas que indicam o efeito da remoção de cada observação sobre os valores ajustados do modelo;

-   COVRATIO (***cov.r***): estatística que indica o efeito da remoção de cada observação sobre a matriz de covariâncias do modelo, em outras palavras, mede a alteração na precisão das estimativas dos parâmetros do modelo;

-   HAT (***hat***): diagonal da matriz de projeção ($H = X(X'X)^{-1}X'$) da solução dos mínimos quadrados, é a métrica de alavancagem.

```{r}
inf = influence.measures(model2)
summary(inf)

inf = influence.measures(model3)
summary(inf)
```

Baseando-se nas medidas de influência acima, que verificam o efeito da remoção de cada uma das observações individualmente, temos que os possíveis pontos de influência são as observações 9 e 27, para ambos os modelos parcimoniosos, e a observação 10, para o segundo. Percebemos também que a observação 27 é a mais crítica, por impactar nas estimativas dos dois parâmetros, nos valores ajustados e na variância do modelo. Também podemos constatar isso graficamente, como se segue a baixo.

```{r}
# DISTANCIA DE COOK

plot(model2, which=4, lwd=5, main="Distância de Cook x Observação", caption=F,
     sub.caption = "preco ~ imposto + areaC")
plot(model3, which=4, lwd=5, main="Distância de Cook x Observação", caption=F,
     sub.caption = "preco ~ imposto + areaT")
```

```{r}
# ALAVANCAGEM

cut = 2*3/27 # 2*p/n
plot(hatvalues(model2), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem",
     sub = "preco ~ imposto + areaC")
abline(h = cut, lty = 2, lwd = 2)
text(hatvalues(model2) * as.integer(hatvalues(model2) > cut),
     cex=0.8, p=1, offset=0.3)


cut = 2*3/27 # 2*p/n
plot(hatvalues(model3), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem",
     sub = "preco ~ imposto + areaT")
abline(h = cut, lty = 2, lwd = 2)
text(hatvalues(model3) * as.integer(hatvalues(model3) > cut),
     cex=0.8, p=1, offset=0.3)


```

As observações 9, 10 e 27 são referentes aos dados:

```{r}
dados[c(9,10,27),c("imposto","areaC","areaT","preco")]
```

Os imóveis 9 e 10 possuem os valores de imposto mais elevados e as maiores áreas de terreno e de construção. De acordo com a relação linear identificada na etapa descritiva e a significância dessas variáveis para o modelo preditivo, podemos dizer que essas características justificam um alto preço de venda. Porém, os valores atribuídos aos imóveis 9 e 10 são muito mais elevados que os esperados pelo modelo proposto a imóveis com os mesmos atributos. Já a observação 27 causa estranheza por ter um valor de imposto tão alto e próximo aos dos imóveis 9 e 10, mesmo tendo menos da metade de suas áreas de terreno e de construção e custando pouco menos da metade que o imóvel 10.

<br>

#### Impacto das remoções das observações

```{r}
# Compara os coeficientes e seus respectivos p-valores de um modelo
# após a remoção de uma observação
impacto = function(m1, m2){
  imp = (coef(m1) - coef(m2))/coef(m1) * 100
  impacto = data.frame(coef_com_i = coef(m1),
                       coef_sem_i = coef(m2),
                       impacto = imp,
                       pval_com_i = summary(m1)$coefficients[,4],
                       pval_sem_i = summary(m2)$coefficients[,4])
  return(impacto)
}
```

-   Observação i=9:

    ```{r}
    model2_sem9 = lm(preco~imposto+areaC,dados,subset=-9)
    impacto(model2,model2_sem9)

    model3_sem9 = lm(preco~imposto+areaT,dados,subset=-9)
    impacto(model3,model3_sem9)
    ```

    A remoção da observação 9 não teve impactos relevantes nos coeficientes dos dois modelos parcimoniosos e também não causou mudança inferencial, uma vez que as variáveis imposto, área construída e área do terreno permaneceram igualmente significativas nos respectivos modelos;

-   Observação i=10:

    ```{r}
    model2_sem10 = lm(preco~imposto+areaC,dados,subset=-10)
    impacto(model2,model2_sem10)

    model3_sem10 = lm(preco~imposto+areaT,dados,subset=-10)
    impacto(model3,model3_sem10)
    ```

    A remoção da observação 10 não causou impactos relevantes nos coeficientes do primeiro modelo parcimonioso e também não ocasionou mudança inferencial, tendo as variáveis imposto e área construída mantido seus níveis de significância. Já no segundo modelo parcimonioso, a remoção da observação 10 ocasionou uma mudança inferencial, uma vez que a variável área de terreno perde sua significância;

-   Observação i=27:

    ```{r}
    model2_sem27 = lm(preco~imposto+areaC,dados,subset=-27)
    impacto(model2,model2_sem27)

    model3_sem27 = lm(preco~imposto+areaT,dados,subset=-27)
    impacto(model3,model3_sem27)
    ```

    A remoção da observação 27 impactou em mudança inferencial nos dois modelos parcimoniosos. Enquanto que no primeiro, a significância da variável área construída é reduzida, no segundo, a variável área do terreno perde completamente sua significância.

<br>

Como o segundo modelo parcimonioso não nos trouxe nenhuma melhoria para o ajuste e as conclusões sobre os pontos de influência não favoreceram a permanência da variável área do terreno, optaremos pelo primeiro modelo parcimonioso com as variáveis imposto e área construída sugerido inicialmente pelo critério de seleção de Akaike.

A partir dos gráficos de resíduos por valores ajustados, de distância de Cook e de alavancagem, podemos fazer as seguintes classificações:

-   Ponto aberrante: observação 10;

-   Pontos de alavanca: observações 9, 10 e 27;

-   Ponto influente: observação 27.

<br>

## Interpretação

Então, concluímos que

$$
preço_i = 0.79 + 2.30*imposto_i + 13.93*areaC_i \quad ,
$$

onde:

-   A cada US\$ 100,00 acrescidos no valor de imposto, aumenta-se, em média, US\$ 2.300,00 no preço de venda;

-   A cada 1.000 metros quadrados de área construída acrescidos, aumenta-se, em média, US\$ 13.930,00 no preço de venda.

<br>

# II. Modelo Gama

## 1. Tempo de Vida de Pacientes com Leucemia

### Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 23, página 182). Dados disponíveis em: [\<https://www.ime.usp.br/\~giapaula/textoregressao.htm\>](https://www.ime.usp.br/~giapaula/textoregressao.htm){.uri}, arquivo ***sobrev.dat***.

O conjunto de dados a seguir refere-se à classificação de pacientes com leucemia segundo a ausência ou presença de uma característica morfológica nas células brancas. Os pacientes classificados de AG positivo foram aqueles identificados com a presença dessa característica e os pacientes classificados em AG negativo os que não apresentaram. O conjunto de dados também inclui o tempo de sobrevivência do paciente (em semanas) após o diagnóstico da doença e o número de células brancas (WBC) no momento do diagnóstico.

Variáveis:

-   ***WBC***: número de células brancas no momento do diagnóstico;

-   ***TEMPO***: tempo de sobrevivência do paciente (em semanas) após o diagnóstico da doença;

-   ***AG***: 0 em caso da ausência da característica e 1 em caso da presença.

Supondo que o tempo de sobrevivência após o diagnóstico segue uma distribuição gama, vamos propor um modelo para explicar o tempo médio de sobrevivência dados $log(WBC)$ e AG (= 1 se positivo, = 0 se negativo).

Denotaremos por $T_{ij}$ o tempo de sobrevivência do i-ésimo paciente com a j-ésima classificação, $i = 1,…,33$ e $j = 1,2$.

```{r}
# Obtendo os dados
dados = read.csv("dados/sobrev.csv")
dados$AG = factor(dados$AG)
attach(dados)
```

<br>

### Análise Descritiva

Médias estimadas para o tempo de sobrevivência, considerando o fator AG:

```{r}
# AG Negativo
dados_ag0 = dados %>% filter(AG==0)
mean(dados_ag0$TEMPO)

# AG Positivo
dados_ag1 = dados %>% filter(AG==1)
mean(dados_ag1$TEMPO)
```

A partir da diferença entre as médias amostrais acima, podemos supor que os pacientes com o fator AG positivo sobreviveram por mais tempo que aqueles com fator AG negativo.

<br>

Coeficientes de variação do tempo de sobrevivência, considerando o fator AG:

```{r}
# Tempo, AG = 0
sd(dados_ag0$TEMPO)/mean(dados_ag0$TEMPO) * 100

# Tempo, AG = 1
sd(dados_ag1$TEMPO)/mean(dados_ag1$TEMPO) * 100
```

<br>

#### Box-plots

Ignorando o fator AG, temos o seguinte boxplot:

```{r}
plot_ly(type = "box", y = TEMPO, name = "TEMPO", color = I("slategray"))
```

Considerando o fator AG, temos os seguintes boxplots:

```{r}
plot_ly(type = "box",
        y = TEMPO, x = AG, name = AG,
        color = AG, colors = c("darkred","darkgreen")) %>% 
  layout(title = "TEMPO x AG")
```

Os gráficos de box-plot evidenciam a assimetria na distribuição da variável tempo de sobrevivência e também apontam a presença de um outlier entre os indivíduos com fator AG negativo. Esse outlier corresponde ao paciente que, mesmo com o fator AG negativo, conseguiu sobreviver a 65 semanas. Nos dados, esse paciente é a 19ª observação.

<br>

#### Densidades, Dispersões e Correlações

Ignorando o fator AG, temos a seguinte densidade aproximada do tempo de sobrevivência:

```{r}
ggplot(dados,aes(x=TEMPO)) +
  geom_density(fill = "slategray", color ="slategray",lwd = 1, alpha = 0.5) +
  ggtitle("Densidade: TEMPO") +
  theme_bw()
```

Considerando o fator AG, temos as seguintes dispersões, densidades e correlações:

```{r}
g = ggpairs(dados[c("WBC","TEMPO")],
            aes(color = AG),
            lower = list(continuous = wrap("smooth",col="black")),
            diag = list(continuous = wrap("densityDiag", alpha = 0.5, size = 1)))
ggplotly(g)
```

De maneira geral, percebemos uma correlação fraca de -0,33 entre as variáveis WBC e TEMPO. Considerando o fator AG, a correlação é praticamente nula no caso de AG negativo e moderada no caso de AG positivo. Em outras palavras, na presença da característica morfológica, o tempo de sobrevivência tende a diminuir conforme o número de celulas brancas aumentam.

<br>

### Ajuste

Supondo que $T_{ij}$ são variáveis aleatórias independentes tais que $T_{ij} \sim Gama(\mu_{ij},\phi)$ e que $g(\mu_{ij}) = \eta_{ij}$, com $\eta_{ij} = \bf{x}_{ij}^\top\beta$, $\bf{x}_{ij}^\top$ contendo os valores das variáveis explicativas $log(WBC)$ e $AG$, e $\beta$ o vetor de parâmetros.

Assumimos que $T_{ij}$ segue uma distribuição Gama de média $\mu_i$ e parâmetro de dispersão $\phi^{-1}$. Vamos, então, propor um modelo cuja parte sistemática é dada por

$$
\log(\mu_{ij}) = \alpha + \gamma_j + \beta\log(WBC_{ij}) \; ,
$$

em que $\gamma_{1} = 0$.

#### Modelo com Ligação Logarítmica

```{r}
model1 = glm(TEMPO ~ log(WBC) + AG, dados, family = Gamma(link = "log"))
resumo = summary(model1)
resumo
```

Para o modelo obtido, ao nível de 5% de significância, as variáveis log(WBC) e AG são significativas.

```{r}
shape = MASS::gamma.shape(model1)

desvio_escal = resumo$deviance * shape$alpha
nivel_descrit = 1 - pchisq(desvio_escal, model1$df.residual)
nivel_descrit
```

Também ao nível de 5% de significância, não rejeitamos a hipótese de que o modelo seja adequado.

<br>

#### Seleção de Variáveis

```{r}
MASS::stepAIC(model1)
```

Pelo critério de seleção de Akaike, devemos manter as duas variáveis no modelo.

<br>

### Diagnóstico

#### Envelope

```{r}
# ENVELOPE
fit.model = model1
source("envel_gama")
```

Pelo gráfico de envelope, verificamos que todos os pontos se encontram dentro das bandas.

```{r}
par(mfrow=c(2,2))

# RESÍDUOS STUDENTIZADOS
residualPlot(model1, type = "deviance", id = TRUE,
             ylab = "res. compon. do desvio", xlab = "valor ajustado",
             pch = 16, smooth = F)
abline(h = c(-2,2), col="red")

# VARIÁVEL Z
w = model1$weights
eta = model1$linear.predictors
z = eta + resid(model1, type="pearson")/sqrt(w)
plot(model1$linear.predictors, z,
     xlab = "Preditor Linear", ylab = "Variável z", pch = 16)

# ALAVANCAGEM
cut = min(sort(hatvalues(model1), decreasing = TRUE)[1:3])
plot(hatvalues(model1), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem")
text(hatvalues(model1) * as.integer(hatvalues(model1) >= cut),
     cex=0.8, p=1, offset=0.3)

# DISTÂNCIA DE COOK
plot(model1, which=4, lwd=3, main = "Distância de Cook", caption = F)
```

No gráfico de resíduos por valores ajustados, percebemos uma boa distribuição dos pontos no intervalo de -2 a 2. Embora seja perceptível também um afunilamento à direita, a quantidade de pontos nessa região não é suficiente para indicar que seja uma tendência. Não há presença de pontos aberrantes, uma vez que todos os pontos estão dentro ou muito próximo do intervalo de -2 a 2. A observação 33 fica em evidência no gráfico de distância de Cook, mas não a consideraremos para análise uma vez que a distância não é expressiva em escala. No gráfico de alavancagem, a observação 2 se destaca e, sendo assim, investigaremos sua possível influência na qualidade do ajuste.

<br>

#### Pontos Influentes

```{r}
summary(influence.measures(model1))
```

As medidas de influência acima apontam apenas para a observação 2 como possível ponto influente.

<br>

#### Impacto das remoções das observações

```{r}
model1_sem2 = glm(TEMPO ~ log(WBC) + AG, dados, subset = -2,
                   family = Gamma(link = "log"))
impacto(model1, model1_sem2)
```

Ao nível de 5% de significância, verificamos que a variável log(WBC) deixa de ser significativa quando removemos a observação 2. Sendo assim, ela causa mudança infefrencial e classifica-se como ponto de alavanca e influente.

<br>

### Interpretação

Com essa análise, chegamos ao seguinte modelo para explicar o tempo médio de sobrevivência:

$$
\begin{aligned}
\log(\mu_{i1}) &= 5.8 - 0.3\log(WBC_{i1}) \; ; \\
\log(\mu_{i2}) &= 6.8 - 0.3\log(WBC_{i2}) \; .
\end{aligned}
$$

Fixando-se o fator $\gamma_{j}$, temos que

$$
\frac{\mu_{j}(x+1)}{\mu_{j}(x)} = \frac{\exp{(5.8+ \gamma_j -0.3(x+1))}}{\exp{(5.8 + \gamma_j - 0.3x)}}
=\exp{(-0.3)
= 0.74} \; .
$$

Alterando-se o fator $\gamma_j$, temos que

$$
\frac{\mu_{i2}}{\mu_{i1}} = \frac{\exp{(5.8 + \gamma_2 - 0.3X_{i2})}}{\exp{(5.8 + \gamma_1 - 0.3X_{i1})}}
= \exp{(\gamma_2)}
= 2.72
$$

De onde concluímos que, ao fixarmos o fator característica morfológica, o acréscimo de 1 unidade à variável $\log(WBC)$ representa, em média, uma redução de 26% do tempo de sobrevivência. Já considerando a característica morfológica, o fato do paciente apresentá-la representa um aumento médio de 172% no tempo de sobrevivência.

<br>

# III. Modelo para Dados Binários

## 1. Dose-Resposta

### Dados

Os conjuntos de dados apresentados a seguir são provenientes de um experimento dose-resposta, conduzido para avaliar a influência dos extratos vegetais "aquoso frio de folhas", "aquoso frio de frutos" e um extrato químico, respectivamente, na morte de um determinado tipo de caramujo. Para cada conjunto, ajustaremos um modelo logístico linear simples e um modelo log-log linear simples. Para o melhor ajuste, usando envelope como critério, encontraremos um intervalo assintótico de 95% para a dose letal $DL_{50}$.

Dados do *Extrato Aquoso Frio de Folhas:*

```{r}
dose1 = read.table("dados/dose1.dat", col.names = c("dose","expostos","mortos"))
dose1 = dose1 %>% mutate(restantes = expostos - mortos,
                         prop.mort = mortos/expostos,
                         prop.rest = restantes/expostos)
dose1
```

Dados do *Extrato Aquoso Frio de Frutos:*

```{r}
dose2 = read.table("dados/dose2.dat", col.names = c("dose","expostos","mortos"))
dose2 = dose2 %>% mutate(restantes = expostos - mortos,
                         prop.mort = mortos/expostos,
                         prop.rest = restantes/expostos)
dose2
```

Dados do *Extrato Químico:*

```{r}
dose3 = read.table("dados/dose3.dat", col.names = c("dose","expostos","mortos"))
dose3 = dose3 %>% mutate(restantes = expostos - mortos,
                         prop.mort = mortos/expostos,
                         prop.rest = restantes/expostos)
dose3
```

### 1.1 Proporção de Caramujos Mortos por Dose

```{r}
p1 = ggplot(dose1, aes(x = dose, y = prop.mort)) +
  geom_col(fill = "darkred") +
  ylab("prop. mortos") +
  labs(title = "Extrato Aquoso Frio de Folhas") +
  theme_bw()

p2 = ggplot(dose2, aes(x = dose, y = prop.mort)) +
  geom_col(fill = "darkred") +
  ylab("prop. mortos") +
  labs(title = "Extrato Aquoso Frio de Frutos") +
  theme_bw()

p3 = ggplot(dose3, aes(x = dose, y = prop.mort)) +
  geom_col(fill = "darkred") +
  ylab("prop. mortos") +
  labs(title = "Extrato Químico") +
  theme_bw()

plot_grid(p1,p2,p3,ncol=2)
```

### 1.2 Modelos Logístico Linear Simples

```{r}
# EAF Folhas
log1 = glm(as.matrix(dose1[3:4]) ~ dose, data = dose1, family=binomial)
summary(log1)

# EAF Frutos
log2 = glm(as.matrix(dose2[3:4]) ~ dose, data = dose2, family=binomial)
summary(log2)

# E Químico
log3 = glm(as.matrix(dose3[3:4]) ~ dose, data = dose3, family=binomial)
summary(log3)
```

#### Testes de Ajuste

```{r}
# EAF Folhas
1 - pchisq(log1$deviance, log1$df.residual)

# EAF Frutos
1 - pchisq(log2$deviance, log1$df.residual)

# E Químico
1 - pchisq(log3$deviance, log1$df.residual)
```

<br>

### 1.3 Modelos Complementar Log-log

```{r}
# EAF Folhas
cloglog1 = glm(as.matrix(dose1[3:4]) ~ dose, data = dose1,
               family = binomial(link = "cloglog"))
summary(cloglog1)

# EAF Frutos
cloglog2 = glm(as.matrix(dose2[3:4]) ~ dose, data = dose2,
               family = binomial(link = "cloglog"))
summary(cloglog2)

# E Químico
cloglog3 = glm(as.matrix(dose3[3:4]) ~ dose, data = dose3,
               family = binomial(link = "cloglog"))
summary(cloglog3)
```

<br>

#### Teste de Ajuste

```{r}
# EAF Folhas
1 - pchisq(cloglog1$deviance, cloglog1$df.residual)

# EAF Frutos
1 - pchisq(cloglog2$deviance, cloglog2$df.residual)

# E químico
1 - pchisq(cloglog3$deviance, cloglog3$df.residual)
```

### 1.4 Envelopes

***Extrato Aquoso Frio de Folhas:***

```{r}
fit.model = log1
ntot = dose1$expostos
source("envelr_bino.txt")

fit.model = cloglog1
ntot = dose1$expostos
source("envelr_bino_cloglog.txt")
```

***Extrato Aquoso Frio de Frutos:***

```{r}
fit.model = log2
ntot = dose2$expostos
source("envelr_bino.txt")

fit.model = cloglog2
ntot = dose2$expostos
source("envelr_bino_cloglog.txt")
```

***Extrato Químico:***

```{r}
fit.model = log3
ntot = dose3$expostos
source("envelr_bino.txt")

fit.model = cloglog3
ntot = dose3$expostos
source("envelr_bino_cloglog.txt")
```

### 1.5 Curvas Logísticas Ajustadas

```{r}
pi_log1 = exp(log1$coeff[1] + log1$coeff[2] * dose1$dose) /
  (1 + exp(log1$coeff[1] + log1$coeff[2] * dose1$dose))

p_log1 = ggplot(dose1, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_log1) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Folhas - Log simples") +
  theme_bw()

pi_cloglog1 = exp(cloglog1$coeff[1] + cloglog1$coeff[2]*dose1$dose) /
  (1 + exp(cloglog1$coeff[1] + cloglog1$coeff[2]*dose1$dose))

p_cloglog1 = ggplot(dose1, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_cloglog1) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Folhas - Complem. Log-log") +
  theme_bw()



pi_log2 = exp(log2$coeff[1] + log2$coeff[2] * dose2$dose) /
  (1 + exp(log2$coeff[1] + log2$coeff[2] * dose2$dose))

p_log2 = ggplot(dose2, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_log2) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Frutos - Log simples") +
  theme_bw()

pi_cloglog2 = exp(cloglog2$coeff[1] + cloglog2$coeff[2]*dose2$dose) /
  (1 + exp(cloglog2$coeff[1] + cloglog2$coeff[2]*dose2$dose))

p_cloglog2 = ggplot(dose2, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_cloglog2) +
  ylab("prop. mortos") +
  ggtitle("E.A.F.Frutos - Complem. Log-log") +
  theme_bw()



pi_log3 = exp(log3$coeff[1] + log3$coeff[2] * dose3$dose) /
  (1 + exp(log3$coeff[1] + log3$coeff[2] * dose3$dose))

p_log3 = ggplot(dose3, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_log3) +
  ylab("prop. mortos") +
  ggtitle("E. Químico - Log simples") +
  theme_bw()

pi_cloglog3 = exp(cloglog3$coeff[1] + cloglog3$coeff[2]*dose3$dose) /
  (1 + exp(cloglog3$coeff[1] + cloglog3$coeff[2]*dose3$dose))

p_cloglog3 = ggplot(dose3, aes(x = dose, y = prop.mort)) +
  geom_point() +
  geom_line(y = pi_cloglog3) +
  ylab("prop. mortos") +
  ggtitle("E. Químico - Complem. Log-log") +
  theme_bw()


plot_grid(p_log1,p_cloglog1,
          p_log2,p_cloglog2,
          p_log3,p_cloglog3, ncol = 2)
```

### 1.6 Dose Letal ($DL_{50}$) para os Modelos Log Linear Simples

```{r}
# DOSE LETAL ESTIMATIVA PONTUAL
DL_100p = function(model,p){
  (1/model$coeff[2])*(log(p/(1-p)) - model$coeff[1])
}


# DOSE LETAL ESTIMATIVA INTERVALAR, 95% DE CONFIANÇA
DL_IC_log = function(model, p, gama){
  db = cbind(-1/model$coeff[2],
             1/(model$coeff[2]^2)*(model$coeff[1]-log(p/(1-p))))
  
  X = model.matrix(model)
  w = model$weights
  W = diag(w)
  
  Var = db %*% solve(t(X) %*% W %*% X) %*% t(db)
  
  LI = DL_100p(model, 0.5) - qnorm((1+gama)/2)*sqrt(Var)
  LS = DL_100p(model, 0.5) + qnorm((1+gama)/2)*sqrt(Var)
  
  return(c(LI,LS))
}
```

```{r}
data.frame(extrato = c("EAF de Folhas","EAF de Frutos", "E Químico"),
           LI = c(DL_IC_log(log1, 0.5, 0.95)[1],
                  DL_IC_log(log2, 0.5, 0.95)[1],
                  DL_IC_log(log3, 0.5, 0.95)[1]),
           DL_100p = c(DL_100p(log1,0.5),DL_100p(log2,0.5),DL_100p(log3,0.5)),
           LS = c(DL_IC_log(log1, 0.5, 0.95)[2],
                  DL_IC_log(log2, 0.5, 0.95)[2],
                  DL_IC_log(log3, 0.5, 0.95)[2]))
```

<br>

## 2. Eficiência do Tratamento de Pacientes com Leucemia

### 2.1 Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 20, página 277). Dados disponíveis em: [\<https://www.ime.usp.br/\~giapaula/textoregressao.htm\>](https://www.ime.usp.br/~giapaula/textoregressao.htm){.uri}, arquivo ***leuc.dat***.

Os dados a seguir referem-se a um estudo com 51 pacientes adultos, previamente diagnosticados com um tipo agudo de leucemia, e que receberam um tipo de tratamento. A eficiência ou não do tratamento foi verificada após um certo período. As variáveis em estudo são:

-   ***idade (***$x_1$***)***: idade do paciente (em anos);

-   ***mancha (***$x_2$***)***: mancha diferencial da doença (em %);

-   ***infilt (***$x_3$***)***: infiltração na medula (em %);

-   ***leuc (***$x_4$***):*** células com leucemia (em %);

-   ***malig (***$x_5$***)***: malignidade da doença ($\times 10^3$);

-   ***tmax (***$x_6$***)***: temperatura máxima pré-tratamento ($\times 10^\circ F$);

-   ***trat (***$y$***)***: tratamento (0: não-satisfatório, 1: satisfatório).

Consideremos o seguinte modelo logístico linear, para explicar a probabilidade de eficiência do tratamento a partir das seis primeiras variáveis explicativas acima:

$$
Y \sim Bernoulli(\pi(\mathbf{x}))
$$

$$
\log \left\{ \frac{\pi(\mathbf{x})}{1-\pi(\mathbf{x})} \right\} = \beta_1 + \beta_2x_2 + ... + \beta_6x_6
$$

```{r}
dados = read.table("dados/leuce.dat",
                   col.names = c("idade","mancha","infilt",
                                 "leuc","malig","tmax",
                                 "trat","tvida","status"))
dados$trat = factor(dados$trat)
dados = dados[1:7]
attach(dados)
```

#### Box-plots

```{r}
p1 = dados %>% ggplot(aes(x = trat, y = idade, fill = trat)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#BC3C29", "#20854E")) +
  ggtitle("idade x tratamento") +
  theme(legend.position = "none")

p2 = dados %>% ggplot(aes(x = trat, y = mancha, fill = trat)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#BC3C29", "#20854E")) +
  ggtitle("mancha diferencial x tratamento") +
  theme(legend.position = "none")

p3 = dados %>% ggplot(aes(x = trat, y = infilt, fill = trat)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#BC3C29", "#20854E")) +
  ggtitle("infiltração x tratamento") +
  theme(legend.position = "none")

p4 = dados %>% ggplot(aes(x = trat, y = leuc, fill = trat)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#BC3C29", "#20854E")) +
  ggtitle("células leucêmicas x tratamento") +
  theme(legend.position = "none")

p5 = dados %>% ggplot(aes(x = trat, y = malig, fill = trat)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#BC3C29", "#20854E")) +
  ggtitle("malignidade x tratamento") +
  theme(legend.position = "none")

p6 = dados %>% ggplot(aes(x = trat, y = tmax, fill = trat)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#BC3C29", "#20854E")) +
  ggtitle("temperatura máxima x tratamento") +
  theme(legend.position = "none")

grid.arrange(p1,p2,p3,p4,p5,p6)
```

Observando os box-plots acima, fica evidente que o tratamento foi mais eficaz em pacientes mais jovens e naqueles com maior porcentagem de células leucêmicas.

<br>

#### Correlograma

```{r}
corrplot::corrplot(cor(dados[1:6]),  method = "color", type = "lower",
                   addCoef.col = "white", tl.col = "black")
```

Dentre as variáveis explicativas, o par ***mancha diferencial*** e ***infiltração na medula*** foi o único com alto grau de correlação. Então, vale estudar modelos considerando as duas individualmente junto as demais.

<br>

### 2.2 Modelo Logístico Linear

#### Modelo Completo

```{r}
model = glm(trat ~ idade + mancha + infilt + leuc + malig + tmax,
            family = binomial)
summary(model)
```

Para o modelo com todas as variáveis fornecidas, mancha, infiltração e malignidade não foram significativas.

<br>

#### Seleção de Variáveis

```{r}
MASS::stepAIC(model)
```

No método stepwise AIC, as variáveis selecionadas foram ***idade***, ***infilt***, ***leuc*** e ***tmax***. Como ***infilt*** e ***mancha*** são fortemente correlacionadas, vamos testar também um modelo com ***mancha*** ao invés de ***infilt***.

<br>

#### Modelos Reduzidos

```{r}
# Com a variável INFILT
modelr1 = glm(trat ~ idade + infilt + leuc + tmax, family = binomial)
summary(modelr1)

# Com a variável MANCHA
modelr2 = glm(trat ~ idade + mancha + leuc + tmax, family = binomial)
summary(modelr2)
```

Os modelo reduzido com a variável ***infilt*** quanto o com a variável ***mancha*** apresentam as mesmas estimativas aproximadas para os parâmetros. Também nos dois, essas variáveis permanecem não significativas. Adiante, estudaremos uma possível influência de pontos sobre a inferência do modelo e avaliaremos a remoção das variáveis.

<br>

#### Testes de Ajuste

```{r}
1 - pchisq(modelr1$deviance, modelr1$df.residual)
1 - pchisq(modelr2$deviance, modelr2$df.residual)
```

Ao nível de 5% de significância, não rejeitamos a hipótese de que os modelos sejam adequados.

<br>

#### Envelopes

```{r}
fit.model = modelr1
source("envel_bino.txt")

fit.model = modelr2
source("envel_bino.txt")
```

Pelos gráficos de envelope, temos que o modelo reduzido com a variável ***mancha*** ficou melhor ajustado e, então, o escolheremos para prosseguir nossa análise.

<br>

### 2.3 Diagnóstico

```{r}
par(mfrow=c(2,2))

# ALAVANCAGEM
cut = min(sort(hatvalues(modelr2), decreasing = TRUE)[1:3])
plot(hatvalues(modelr2), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem")
text(hatvalues(modelr2) * as.integer(hatvalues(modelr2) >= cut),
     cex=0.8, p=1, offset=0.4)

# DISTÂNCIA DE COOK
plot(modelr2, which=4, lwd=3, main = "Distância de Cook", caption = F)

# RESÍDUO COMPONENTE DO DESVIO POR ÍNDICE
plot(residuals(modelr2), pch = 16,
     ylab = "res. compon. do desvio", xlab = "índice")
abline(h = c(-2,2), col="red")
```

No gráfico de resíduo componente do desvio, verificamos que os pontos estão bem distribuídos aleatoriamente e sem nenhuma observação aberrante muito além dos limites de confiança. Nos gráficos de alavancagem e distância de Cook, destacam--se os pontos 2, 13, 32, 47 e 48. A seguir, verificaremos se há influência desses pontos sobre a inferência do modelo.

<br>

#### Pontos Influentes

```{r}
summary(influence.measures(modelr2))
```

#### Impacto dos Pontos Influentes

***Observação 2***

```{r}
modelr2_sem2 = glm(trat ~ idade + mancha + leuc + tmax, subset = -2,
                   family = binomial)
impacto(modelr2, modelr2_sem2)[3:5]
```

A 5% de significância, removendo-se a observação 2, a variável ***idade*** deixa de ser significativa.

<br>

***Observação 13***

```{r}
modelr2_sem13 = glm(trat ~ idade + mancha + leuc + tmax, subset = -13,
                   family = binomial)
impacto(modelr2, modelr2_sem13)[3:5]
```

A 5% de significância, removendo-se a observação 13, não há mudança inferencial no modelo.

<br>

***Observação 32***

```{r}
modelr2_sem32 = glm(trat ~ idade + mancha + leuc + tmax, subset = -32,
                   family = binomial)
impacto(modelr2, modelr2_sem32)[3:5]
```

A 5% de significância, removendo-se a observação 32, a variável ***idade*** deixa de ser significativa.

<br>

***Observação 47***

```{r}
modelr2_sem47 = glm(trat ~ idade + mancha + leuc + tmax, subset = -47,
                   family = binomial)
impacto(modelr2, modelr2_sem47)[3:5]
```

A 5% de significância, removendo-se a observação 47, não há mudança inferencial no modelo.

<br>

Observação 48

```{r}
modelr2_sem48 = glm(trat ~ idade + mancha + leuc + tmax, subset = -48,
                   family = binomial)
impacto(modelr2, modelr2_sem48)[3:5]
```

A 5% de significância, removendo-se a observação 48, a variável ***idade*** deixa de ser significativa.

<br>

### 2.4 Modelo Logístico Linear -  Reajuste

As variáveis ***mancha*** e ***infilt*** não foram significativas em nenhuma circustância vista anteriormente. Então, podemos considerar removê-las. Além disso, a variável ***idade*** deixou de ser significativa com a remoção de algumas observações. Então, testaremos a seguir dois modelos sem as variáveis ***mancha*** e ***infilt***: um com a variável ***idade*** e outro sem.

```{r}
# Com a variável IDADE
modelr3 = glm(trat ~ idade + leuc + tmax, family = binomial)
summary(modelr3)

# Sem a variável IDADE
modelr4 = glm(trat ~ leuc + tmax, family = binomial)
summary(modelr4)
```

Em ambos os modelos, a 5% de significâncias, todas as variáveis são significativas.

<br>

#### Testes de Ajuste

```{r}
1 - pchisq(modelr3$deviance, modelr3$df.residual)
1 - pchisq(modelr4$deviance, modelr4$df.residual)
```

Ao nível de 5% de significância, não rejeitamos a hipótese de que os modelos sejam adequados.

<br>

#### Envelopes

```{r}
fit.model = modelr3
source("envel_bino.txt")

fit.model = modelr4
source("envel_bino.txt")
```

Pelos gráficos de envelope, temos que os dois modelos ficaram bem ajustados. Então, pelo princípio da parcimônia, optaremos pelo modelo sem a variável ***idade***.

<br>

#### Qualidade do Ajuste - Hosmer-Lemeshow

```{r}
HosmerLemeshowTest(fit=fitted(modelr4), trat, ngr=10, X=cbind(leuc, tmax))$gof
```

Pelo teste de Homser-Lemeshow, ao nível de 5% de significância, não rejeitamos a hipótese de bom ajuste do modelo.

<br>

### 2.5 Diagnóstico

```{r}
par(mfrow=c(2,2))

# ALAVANCAGEM
cut = min(sort(hatvalues(modelr4), decreasing = TRUE)[1:3])
plot(hatvalues(modelr4), pch = 16,
     xlab = "observação", ylab = "medida h", main = "Alavancagem")
text(hatvalues(modelr4) * as.integer(hatvalues(modelr4) >= cut),
     cex=0.8, p=1, offset=0.4)

# DISTÂNCIA DE COOK
plot(modelr4, which=4, lwd=3, main = "Distância de Cook", caption = F)

# RESÍDUO COMPONENTE DO DESVIO POR ÍNDICE
plot(residuals(modelr4), pch = 16,
     ylab = "res. compon. do desvio", xlab = "índice")
abline(h = c(-2,2), col="red")
```

<br>

Pelo gráfico de resíduo componente do desvio, verificamos que os pontos estão bem distribuídos aleatoriamente no intervalo (-2,2) e sem pontos aberrantes para muito além dele. Nos gráficos de alavancagem e distância de Cook, destacam-se os pontos 2, 32, 40 e 42. Então, a seguir vamos verificar a se há influência desses pontos sobre a inferência do modelo.

<br>

#### Pontos Influentes

```{r}
summary(influence.measures(modelr4))
```

#### Impacto dos Pontos Influentes

***Observação 2***

```{r}
modelr4_sem2 = glm(trat ~ leuc + tmax, subset = -2, family = binomial)
impacto(modelr4, modelr4_sem2)[3:5]
```

A 5% de significância, removendo-se a observação 2, não há mudança inferencial no modelo.

<br>

***Observação 32***

```{r}
modelr4_sem32 = glm(trat ~ leuc + tmax, subset = -32, family = binomial)
impacto(modelr4, modelr4_sem32)[3:5]
```

A 5% de significância, removendo-se a observação 32, não há mudança inferencial no modelo.

<br>

***Observação 40***

```{r}
modelr4_sem40 = glm(trat ~ leuc + tmax, subset = -40, family = binomial)
impacto(modelr4, modelr4_sem40)[3:5]
```

A 5% de significância, removendo-se a observação 40, não há mudança inferencial no modelo.

<br>

***Observação 48***

```{r}
modelr4_sem48 = glm(trat ~ leuc + tmax, subset = -48, family = binomial)
impacto(modelr4, modelr4_sem48)[3:5]
```

A 5% de significância, removendo-se a observação 48, não há mudança inferencial no modelo.

<br>

### 2.6 Interpretação

Com essa análise, chegamos ao seguinte modelo para explicar a probabilidade de eficiência do tratamento:

$$
\log \left\{ \frac{\pi(\mathbf{x})}{1-\pi(\mathbf{x})} \right\} = 70.82 +
0.34 \cdot leuc - 0.07 \cdot tmax \; .
$$

Como ilustração, ao fixarmos a temperatura máxima e considerarmos um aumento de 1% no número de células leucêmicas, a razão de chances de tratamento satisfatório, denotada por $\psi_{CL}$, é estimada em

$$
\psi_I = e^{0.34} = 1.40 \; .
$$

Isto significa que, sob uma mesma temperatura máxima, o aumento de 1% no número de células leucêmicas representa uma aumento de 40% na chance do tratamento ser satisfatório.

<br>

## 3. Taxa Anual de Câncer Nasal

### 3.1 Dados

Exemplo disponível em: Paula, G. A. (2013). [Modelos de Regressão com Apoio Computacional](https://www.ime.usp.br/~giapaula/texto_2013.pdf). São Paulo, SP: IME-USP. (Exercício 6, página 345). Dados disponíveis em: <https://www.ime.usp.br/~giapaula/textoregressao.htm>, arquivo ***canc1.dat***.

Os dados a seguir são provenientes de um estudo de seguimento para estudar a associação entre a taxa anual de câncer nasal em trabalhadores de uma refinaria de níquel do País de Gales e algumas variáveis explicativas: ***idade*** no primeiro emprego (4 níveis), ***ano*** do primeiro emprego (4 níveis) e ***tempo*** decorrido desde o primeiro emprego (5 níveis). São também apresentados o ***número de casos*** de câncer nasal e o ***total*** de pessoas-anos para cada combinação desses três fatores. Nesse trabalho foi proposto um modelo log-linear com resposta de Poisson, sendo o número de casos de câncer nasal com ***offset*** dado por ***log(pessoas-anos)**.*

As variáveis e suas classes:

-   ***idade***: 1 (\<20), 2 (20-27), 3 (27.5 - 34.9), 4 (35+), em anos;

-   ***ano***: 1 (\<1910), 2 (1910-1914), 3 (1915-1919), 4 (1920-1924), em anos;

-   ***tempo***: 1 (0-19), 2 (20-29), 3 (30- 39), 4 (40-49), 5 (50+), em anos.

<br>

#### Box-plots

```{r,include=FALSE}
dados = read.table("dados/canc1.dat")
                   
d1 = dados[,1:5]; colnames(d1) = c("idade","ano","tempo","ncasos","total")
d2 = dados[,6:10]; colnames(d2) = c("idade","ano","tempo","ncasos","total")
d3 = dados[,11:15]; colnames(d3) = c("idade","ano","tempo","ncasos","total")

dados = rbind(d1,d2,d3) %>% arrange(idade,ano,tempo)
dados$idade = factor(dados$idade)
dados$ano = factor(dados$ano)
dados$tempo = factor(dados$tempo)

attach(dados)
```

```{r,echo=FALSE}
p1 = dados %>% ggplot(aes(x = idade, y = ncasos)) +
  geom_boxplot(fill="#DF8F44") +
  ggtitle("número de casos x idade") +
  theme(legend.position = "none")

p2 = dados %>% ggplot(aes(x = ano, y = ncasos)) +
  geom_boxplot(fill="#B24745") +
  ggtitle("número de casos x ano") +
  theme(legend.position = "none")

p3 = dados %>% ggplot(aes(x = tempo, y = ncasos)) +
  geom_boxplot(fill="#6A6599") +
  ggtitle("número de casos x tempo") +
  theme(legend.position = "none")

grid.arrange(p1,p2,p3)
```

<br>

### 3.2 Modelo Log-linear de Resposta Poisson

Denotamos por $Y_{ijk}$ o número de casos de câncer nasal para o i-ésimo nível de idade no primeiro emprego, para o j-ésimo ano do primeiro emprego e para o k-ésimo tempo decorrido desde o primeiro emprego, $i,j=1,...,4$ e $k=1,...,5$. Supomos, então, que

$$
Y_{ijk} \sim Poisson(\lambda_{ijk} t_{ijk}), 
$$

em que $\lambda_{ijk}$ é a taxa média de casos de câncer nasal por unidade de tempo para a idade i, ano j e tempo k. O modelo saturado, nesse caso, é dado por

$$
\log(\lambda_{ijk}t_{ijk}) = \alpha + \beta_i + \gamma_j + \delta_k, 
$$

em que $\beta_i$ é o efeito da i-ésima classe de idade no primeiro emprego, sendo $\beta_1 = 1(<20)$; $\gamma_j$ o efeito da j-ésima classe de ano do primeiro emprego, sendo $\gamma_1 = 1(<1910)$; $\delta_k$ o efeito da k-ésima classe de tempo decorrido desde o primeiro emprego, sendo $\delta_1 = 1(0-19)$.

<br>

#### Modelo Saturado

```{r,echo=FALSE}
model = glm(ncasos ~ idade + ano + tempo + offset(log(total)), family = poisson)
summary(model)
```

#### Envelope

```{r,echo=FALSE}
fit.model = model
source("envel_pois.txt")
```

<br>

### 3.3 Diagnóstico

```{r,echo=FALSE}
par(mfrow=c(2,2))

# ALAVANCAGEM
cut = sort(hatvalues(model), decreasing = TRUE)[3]
id = as.integer(hatvalues(model) >= cut)
id[id==0] = NA
plot(y = hatvalues(model), x = model$fitted.values, pch = 16,
     xlab = "valor ajustado", ylab = "medida h", main = "Alavancagem")
text(y = hatvalues(model)*id, x = model$fitted.values*id, cex=0.8, p=1, offset=0.2)

# DISTÂNCIA DE COOK
plot(model, which=4, lwd=3, main = "Distância de Cook", caption = F)

# RESÍDUO COMPONENTE DO DESVIO POR ÍNDICE
id = as.integer(resid(model,type="deviance") > 2|resid(model,type="deviance") < -2)
id[id==0] = NA
plot(resid(model,type = "deviance"), pch = 16, ylim=c(-2.5,2.5),
     ylab = "res. compon. do desvio", xlab = "índice")
abline(h = c(-2,2), col="red")
text(resid(model,type="deviance")*id, cex=0.8, pos=1, offset=0.2)

# VARIÁVEL Z
w = model$weights
eta = model$linear.predictors
z = eta + resid(model, type="pearson")/sqrt(w)
plot(model$linear.predictors, z,
     xlab = "Preditor Linear", ylab = "Variável z", pch = 16)
```

Pelos gráficos acima, percebemos que as observações 62 e 63 se destacam nos gráficos de alavancagem e distância de Cook, caracterizando-se como pontos de alavanca e possíveis pontos de influência. A observação 52 se afasta um pouco do limite superior do intervalo de confiança para os resíduos componentes do desvio e será considerada como um ponto aberrante. A seguir, estudaremos a influência desses três pontos sobre o ajuste do modelo.

<br>

#### Pontos Influentes

```{r,echo=FALSE}
options(scipen=999)
```

Observação 52:

```{r,echo=FALSE}
model_sem52 = glm(ncasos ~ idade + ano + tempo + offset(log(total)),
                  subset = -52, family = poisson)
impacto(model, model_sem52)[,3:5]
```

Observação 62

```{r,echo=FALSE}
model_sem62 = glm(ncasos ~ idade + ano + tempo + offset(log(total)),
                  subset = -62, family = poisson)
impacto(model, model_sem62)[,3:5]
```

Observação 63:

```{r,echo=FALSE}
model_sem63 = glm(ncasos ~ idade + ano + tempo + offset(log(total)),
                  subset = -63, family = poisson)
impacto(model, model_sem63)[,3:5]
```

Ao nível de 5% de significância, nenhuma das remoções testadas acima ocasionou mudanças inferenciais nas estimativas dos parâmetros.

<br>

### 3.4 Interpretação

Com essa análise, confirmamos o modelo saturado para explicar a taxa anual de casos de câncer nasal.

$$
\log(\lambda_{ijk}t_{ijk}) = \alpha + \beta_i + \gamma_j + \delta_k 
$$

```{r}
resumo = summary(model)
table = data.frame(Efeito = c("Constante","20-27","27.5-34.9","35+",
                              "1910-1914","1915-1919","1920-1924",
                              "20-29","30-39","40-49","50+"),
                   Parametros = c("alfa",
                                  "beta2","beta3","beta4",
                                  "gama2","gama3","gama4",
                                  "delta2","delta3","delta4","delta5"),
                   Estimativa = resumo$coefficients[,1],
                   E.Padrao = resumo$coefficients[,2])
knitr::kable(table, "pipe")
```

Notamos, então, que as estimativas acima são significativamente diferentes de 0 e que há fortes indícios de que a taxa anual de câncer nasal cresce exponencialmente com o aumento da idade no primeiro emprego e o tempo decorrido desde o primeiro emprego, mas decresce exponencialmente com o aumento de anos do primeiro emprego.
